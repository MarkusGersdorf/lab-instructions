# Model Deployment via GitOps

We deployed our `jukebox` model in experiment environment manually, but for the higher environments we need to store the definitions in Git and deploy our models via Argo CD to get all the benefits that GitOps brings.

## üöó Modelcar and GitOpsifying the Deployment

When a new model version is generated by the training pipeline, whether triggered by a code change or a monitoring alert, our goal is to ensure it‚Äôs deployed automatically if it shows better performance (no worries, we'll make sure only the best models make it, just hang in there üòâ). Alongside automation, we prioritize traceability, immutability, and reproducibility in the deployment process.

To support these requirements, we use KServe's **ModelCars**, a feature designed to simplify model deployment by containerizing models as Open Container Initiative (OCI) images. With ModelCars, each model version is packaged into a container image, allowing us to leverage benefits like version tracking and streamlined scaling.

When the pipeline detects a git push event, it tags the model version with the git commit ID. This identifier links the model back to its source code changes, giving us context on why and how it was built.

Once the model artifact and its versioning info are created, the pipeline pushes this update to the `mlops-gitops/model-deployment/` repository. Argo CD then recognizes this change, updating the `InferenceService` configuration in OpenShift. This triggers an automated rollout of the new model version, seamlessly integrating it into production.

# Deploying Jukebox 

1. In your code server IDE, open `mlops-gitops/values.yaml` file and **swap** `enabled: false` to `enabled: true` as shown below for each environment definitions:

    <div class="highlight" style="background: #f7f7f7">
    <pre><code class="language-yaml">
        # Test App of Apps for Models
        - name: model-deployments
          enabled: true
          source_path: "."
          helm_values:
            - test/values.yaml
        # Production App of Apps for Models
        - name: model-deployments
          enabled: true
          source_path: "."
          helm_values:
            - prod/values.yaml
    </code></pre></div>

2. Let's add `jukebox` model definition under `model-deployments/test/values.yaml` and `model-deployments/prod/values.yaml` files as follow. This will take a model deployment helm-chart from a generic helm chart repository and apply the additional configuration to it from the `values` section. 

    ```yaml
      # Jukebox
      jukebox:
        name: jukebox
        enabled: true
        source: https://<GIT_SERVER>/<USER_NAME>/mlops-helmcharts.git
        source_ref: main
        source_path: charts/model-deployment/simple
        values:
            name: jukebox
            version: latest
    ```
3. Let's get this deployed of course - it's not real unless its in git!

    ```bash
    cd /opt/app-root/src/mlops-gitops
    git add .
    git commit -m  "üê∞ ADD - app-of-apps and jukebox to test üê∞"
    git push 
    ```

4. With the values enabled, and the first application listed in the test environment - let's tell Argo CD to start picking up changes to these environments. To do this, simply update the helm chart we installed at the beginning of this exercise:

    ```bash
    cd /opt/app-root/src/mlops-gitops
    helm upgrade --install argoapps --namespace <USER_NAME>-mlops .
    ```

5. You should see the two Jukebox application, one for `test` and one for `prod` deployed in Argo CD. 


