# Model Deployment via GitOps

We deployed our `jukebox` model in experiment environment manually, but for the higher environments we need to store the definitions in Git and deploy our models via Argo CD to get all the benefits that GitOps brings.

## üöó Modelcar and GitOpsifying the Deployment

When a new model version is generated by the training pipeline, whether triggered by a code change or a monitoring alert, our goal is to ensure it‚Äôs deployed automatically if it shows better performance (no worries, we'll make sure only the best models make it, just hang in there üòâ). Alongside automation, we prioritize traceability, immutability, and reproducibility in the deployment process.

To support these requirements, we use KServe's **ModelCars**, a feature designed to simplify model deployment by containerizing models as Open Container Initiative (OCI) images. With ModelCars, each model version is packaged into a container image, allowing us to leverage benefits like version tracking and streamlined scaling.

When the pipeline detects a git push event, it tags the model version with the git commit ID. This identifier links the model back to its source code changes, giving us context on why and how it was built.

Once the model artifact and its versioning info are created, the pipeline pushes this update to the `mlops-gitops/model-deployment/` repository. Argo CD then recognizes this change, updating the `InferenceService` configuration in OpenShift. This triggers an automated rollout of the new model version, seamlessly integrating it into production.

# Deploying Jukebox 

1. Just like we did with our toolings, we need to generate `ApplicationSet` definition for our model deployment. We will have two seperate AppSet definition; one is for `test` and one is for `prod` environment. For the enablement simplicity reasons, we keep them in the same repository. However in the real life, you may also like to take prod definitions into another repository where you only make changes via Pull Requests with a protected `main` branch. We keep AppSet definition separate so that it'll be easy to take the prod definition into another place later on :)

Let's update the AppSet definition with `CLUSTER_DOMAIN` and `USER_NAME` definition just like before. Open up the `appset-test.yaml` and `appset-prod.yaml` files and replace the values. For the lazy ones we also have the commands:

  ```bash
      sed -i -e 's/CLUSTER_DOMAIN/<CLUSTER_DOMAIN>/g' /opt/app-root/src/mlops-gitops/appset-test.yaml
      sed -i -e 's/USER_NAME/<USER_NAME>/g' /opt/app-root/src/mlops-gitops/appset-test.yaml
      sed -i -e 's/CLUSTER_DOMAIN/<CLUSTER_DOMAIN>/g' /opt/app-root/src/mlops-gitops/appset-prod.yaml
      sed -i -e 's/USER_NAME/<USER_NAME>/g' /opt/app-root/src/mlops-gitops/appset-prod.yaml
  ```


2. Let's add `jukebox` model definition under `model-deployments/test/jukebox/config.yaml` and `model-deployments/prod/jukebox/config.yaml` files as follow. This will take a model deployment helm-chart from a generic helm chart repository and apply the additional configuration such as image version. 

    ```yaml
    chart_name: model-deployment/simple
    name: jukebox
    version: latest
    image_repository: quay.io
    image_namespace: rhoai
    ```
3. Let's get this deployed of course - it's not real unless its in git!

    ```bash
    cd /opt/app-root/src/mlops-gitops
    git add .
    git commit -m  "üê∞ ADD - appsets and jukebox to deploy üê∞"
    git push 
    ```

4. With the `jukebox` values stored in Git, now let's tell Argo CD to start picking up changes to these environments. To do this, simply we need to create ApplicationSets:

    ```bash
    oc apply -f /opt/app-root/src/mlops-gitops/appset-test.yaml -n <USER_NAME>-mlops
    oc apply -f /opt/app-root/src/mlops-gitops/appset-prod.yaml -n <USER_NAME>-mlops
    ```

5. You should see the two Jukebox application, one for `test` and one for `prod` deployed in Argo CD. 


TODO: add screenshots